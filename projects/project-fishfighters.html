<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish Fighters | Najim Bakkali</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body class="project-page">

    <nav>
        <a href="../index.html">Home</a>
        <a href="../projects.html">Projects</a>
        <a href="../contact.html">Contact</a>
    </nav>

    <main>

        <!-- ========================= -->
        <!--        HEADER SECTION     -->
        <!-- ========================= -->
        <section class="project-header">

            <h1 class="project-title">Fish Fighters</h1>
            <p class="project-subtitle">A personal C++ tower defense project built with SFML.</p>

            <!-- IMAGE CAROUSEL -->
            <div class="carousel-container">

                <!-- Radio buttons -->
                <input type="radio" name="slides" id="slide1" checked>
                <input type="radio" name="slides" id="slide2">
                <input type="radio" name="slides" id="slide3">

                <!-- Slides -->
                <div class="carousel-slides">

                    <div class="carousel-slide">
                        <img src="../img/hacknescape_1.png" alt="Fish Fighters Screenshot">
                    </div>

                    <div class="carousel-slide">
                        <img src="../img/hacknescape_2.png" alt="Fish Fighters Screenshot">
                    </div>

                    <div class="carousel-slide">
                        <img src="../img/hacknescape_3.png" alt="Fish Fighters Screenshot">
                    </div>

                </div>

                <!-- Arrows for slide 1 -->
                <label for="slide3" class="carousel-arrow left-arrow left1">&#10094;</label>
                <label for="slide2" class="carousel-arrow right-arrow right1">&#10095;</label>

                <!-- Arrows for slide 2 -->
                <label for="slide1" class="carousel-arrow left-arrow left2">&#10094;</label>
                <label for="slide3" class="carousel-arrow right-arrow right2">&#10095;</label>

                <!-- Arrows for slide 3 -->
                <label for="slide2" class="carousel-arrow left-arrow left3">&#10094;</label>
                <label for="slide1" class="carousel-arrow right-arrow right3">&#10095;</label>

            </div>


            <div class="project-info-layout">

                <!-- SIDEBAR TECH INFO -->
                <aside class="project-sidebar">

                    <h3>Platform:</h3>
                    <p>Windows PC</p>

                    <h3>Engine:</h3>
                    <p>Custom C++ Engine (SFML)</p>

                    <h3>Language:</h3>
                    <p>C++20</p>

                    <h3>Tools Used:</h3>
                    <p>Visual Studio 2022, SFML 3.0, ImGui, CMake</p>

                    <h3>Duration:</h3>
                    <p>3 months</p>

                    <h3>Team Size:</h3>
                    <p>1</p>

                    <h3>Role:</h3>
                    <p>Gameplay Programmer, Tools Programmer, Technical Designer</p>

                </aside>

                <!-- OVERVIEW -->
                <section class="project-overview">

                    <h2>Overview</h2>

                    <p>
                        Fish Fighters started as a personal challenge to push myself beyond the short, contained projects
                        I had done before. I wanted to understand what it really takes to structure a larger game, the kind
                        that forces you to think ahead instead of just writing code until it works.
                    </p>

                    <p>
                        A tower-defense game inspired by <em>The Battle Cats</em> felt like the perfect project.
                        It’s simple enough to build alone, but it hides just enough complexity to make you think carefully
                        about architecture, game flow, and data organization.
                    </p>

                    <p>
                        This project wasn’t about making the flashiest game possible. It was about learning how to build
                        something clean and modular, something that could grow without collapsing under its own weight.
                    </p>

                    <h2>Project Goals</h2>

                    <ul>
                        <li>Build a complete small game entirely in modern C++.</li>
                        <li>Design clean, modular systems (state machines, data-driven units, etc.).</li>
                        <li>Experiment with JSON-driven gameplay data.</li>
                        <li>Practice maintainable architecture over rapid prototyping.</li>
                        <li>Develop tools to iterate on gameplay without recompilation.</li>
                    </ul>

                    <h2>Links</h2>

                    <a href="https://github.com/Najimandroid/Fish_Fighters"
                       class="btn" target="_blank">
                        View Source Code on GitHub
                    </a>

                </section>

            </div>

        </section>

        <hr class="section-divider">


        <!-- ========================= -->
        <!--       VIDEO SECTION       -->
        <!-- ========================= -->
        <section class="project-video">

            <h2>Demo Reel</h2>

            <div class="video-wrapper">
                <iframe width="100%" height="500"
                        src="https://www.youtube.com/embed/OKkgqlkqQys"
                        title="Fish Fighters Gameplay Video"
                        frameborder="0"
                        allowfullscreen>
                </iframe>
            </div>

        </section>

        <hr class="section-divider">


        <!-- ========================= -->
        <!--      TECHNICAL SECTION    -->
        <!-- ========================= -->
        <section>

            <h2>Technical Breakdown</h2>

            <details class="technical-section">
                <summary>Project Architecture</summary>
                <div class="technical-content">
                    <p>
                        When I started Fish Fighters, my goal wasn’t simply to make a game — it was to
                        build a maintainable codebase with clear ownership, modular systems, and predictable behavior.
                    </p>
                </div>
            </details>

            <details class="technical-section">
                <summary>Game Entities</summary>
                <div class="technical-content">

                    <p>
                        All units and enemies in the game share the same underlying architecture. Instead of maintaining two
                        completely different systems, I designed a single <code>Entity</code> class capable of representing
                        anything that enters the battlefield. The goal was to keep the core gameplay logic centralized while
                        allowing every type of creature to define its identity through external data.
                    </p>

                    <h3>A Single Entity System</h3>

                    <p>
                        Every entity is built from a common structure called <code>EntityData</code>, loaded from JSON.
                        It contains everything the game needs: health, attack values, movement speed, animations,
                        and special attributes like knockback distance or attack cooldowns. This lets the engine treat
                        units and enemies exactly the same way during combat while still giving them distinct behavior.
                    </p>

                    <p>
                        Once created, an <code>Entity</code> instance keeps its own runtime state using
                        <code>EntityRuntimeData</code> (current HP, timers, stagger state, knockback counters, and so on),
                        while <code>EntityData</code> remains immutable. This separation keeps the gameplay code safe:
                        read-only static data on one side, dynamic battle values on the other.
                    </p>

                    <h3>Composition Over Inheritance</h3>

                    <p>
                        Entity behavior is not determined through a giant inheritance tree.
                        Instead, the Entity class delegates its logic to several small components:
                    </p>

                    <ul>
                        <li><strong>Movement component</strong> for forward motion and knockback.</li>
                        <li><strong>Combat component</strong> for attack timing, ranges, and damage application.</li>
                        <li><strong>Animation controller</strong> handling sprite playback based on state.</li>
                        <li><strong>State machine</strong> that coordinates the entity’s current behavior.</li>
                    </ul>

                    <p>
                        Each component reads only the data it needs from <code>EntityData</code> and operates independently.
                        This makes it easier to modify or extend the gameplay without rewriting the whole system.
                    </p>

                    <h3>Animation System</h3>

                    <p>
                        Animations come directly from JSON as well: sprite sheets, frame counts, timing, offsets, and scaling.
                        The animation controller blends this information with the state machine so the correct animation plays
                        automatically whenever the entity changes behavior. Since animations are fully data-driven, adding a
                        new unit or enemy is simply a matter of dropping its sprite sheet and writing its JSON entry.
                    </p>

                    <h3>Runtime Behavior</h3>

                    <p>
                        Once on the battlefield, each entity updates every frame according to its state machine.
                        Movement, attacking, taking hits, knockback, and dying all go through well-defined transitions.
                        The gameplay layer sees entities only through a clean interface — move, attack, receive damage —
                        which helps keep the Stage system simple.
                    </p>

                    <h3>Why this architecture scales</h3>

                    <p>
                        By centralizing all gameplay logic in one Entity class and letting JSON define variants,
                        the system stays easy to maintain. Adding content never requires new C++ classes.
                        Testing becomes faster because every unit is governed by the same rules, and balancing becomes
                        largely a data-editing process. This architecture also makes it possible to integrate new mechanics
                        or unit types by expanding the components instead of rewriting entire subsystems.
                    </p>

                </div>
            </details>

            <details class="technical-section">
                <summary>Entities’ State Machine</summary>
                <div class="technical-content">

                    <p>
                        Every entity in the game — unit or enemy — is driven by a small but highly expressive state machine.
                        The idea was simple: rather than scattering gameplay logic across many conditionals, every piece of an
                        entity’s behavior should flow through a predictable sequence of states. This made the system both easy to
                        debug and easy to extend whenever I introduced a new mechanic.
                    </p>

                    <h3>Why a State Machine?</h3>

                    <p>
                        Combat entities constantly alternate between distinct modes of behavior: walking, attacking, being knocked back,
                        recovering, or dying. Without a clear structure, these transitions quickly turn messy and hard to maintain.
                        A finite state machine solves this by forcing every entity to exist in exactly one state at a time,
                        with explicit rules determining how it moves to the next one.
                    </p>

                    <p>
                        Instead of writing different logic for units and enemies, both rely on the same state machine.
                        The difference comes from <code>EntityData</code>: attack timings, movement speed, stagger duration,
                        knockback strength, and animation metadata all come from the JSON definition.
                        As a result, the state machine does not need special cases for each creature type.
                    </p>

                    <h3>State Architecture</h3>

                    <p>
                        Each state is a small C++ class inheriting from a common base (<code>EntityState</code>) and implements
                        its own behavior through three simple methods: <code>enter()</code>, <code>update()</code>,
                        and <code>exit()</code>. An <code>EntityStateMachine</code> object lives inside every <code>Entity</code>
                        and holds the current state.
                    </p>

                    <ul>
                        <li><strong>IdleState</strong>: Waiting for the next action (rarely used in combat flow).</li>
                        <li><strong>WalkState</strong>: Moving toward the opposing base or the closest enemy.</li>
                        <li><strong>AttackState</strong>: Handling attack wind-up, hit timing, and recovery.</li>
                        <li><strong>KnockbackState</strong>: Pushed backward after taking a strong hit.</li>
                        <li><strong>StaggerState</strong>: Temporarily disabled after being damaged.</li>
                        <li><strong>DieState</strong>: Playing the death animation and removing the entity.</li>
                    </ul>

                    <p>
                        Each state is intentionally small. For example, <code>WalkState</code> only handles forward motion
                        and checks whether the entity should transition to attacking. <code>AttackState</code> manages the
                        attack timer and triggers damage at the exact hit frame. This separation keeps behavior modular
                        and prevents “god classes”.
                    </p>

                    <h3>Driving the Animation System</h3>

                    <p>
                        The state machine is closely tied to the animation controller. Whenever a state becomes active,
                        it requests the correct animation (walk, hit, knockback, death) directly from <code>EntityData</code>.
                        Timing remains perfectly consistent because states and animations share the same metadata.
                        This creates smooth visuals without any hardcoded frame values in the gameplay code.
                    </p>

                    <h3>Transitions and Decision Making</h3>

                    <p>
                        The entity makes decisions through small triggers scattered across the update cycle:
                    </p>

                    <ul>
                        <li>Clash detection switches from walking to attacking.</li>
                        <li>Receiving damage may trigger stagger or knockback depending on attack strength.</li>
                        <li>HP reaching zero transitions to the death state.</li>
                    </ul>

                    <p>
                        Transitions stay clean and readable because no state tries to do the job of another.
                        The entity is always in a well-defined phase of its behaviour, which makes bugs much easier
                        to spot and eliminates edge cases where multiple systems fight over control.
                    </p>

                    <h3>Why this design works</h3>

                    <p>
                        This state machine architecture allowed me to add new behaviors without breaking existing ones.
                        For example, introducing knockback required only one additional state and a small modification
                        to the damage system. Everything else — animations, movement, transitions — already fit into the
                        structure naturally.
                    </p>

                    <p>
                        This approach also scales well for future work. Adding mechanics like charging attacks,
                        special abilities, or unique enemy behaviors can be done by simply creating new states
                        rather than modifying old ones. This keeps the Entity class stable and lets complexity grow
                        in a controlled, modular way.
                    </p>

                </div>
            </details>

            <details class="technical-section">
                <summary>Stages, Waves & Rewards</summary>
                <div class="technical-content">

                    <h4>Role of <code>StageData</code></h4>
                    <p>
                        <code>StageData</code> is the level blueprint: it describes a stage’s rules (limits, base health, length),
                        visuals (backgrounds, base textures), which enemy waves will appear, and what rewards the player receives
                        on completion. At runtime the <code>Stage</code> is initialized from a <code>StageData</code> instance so
                        the gameplay code can remain generic and driven by data only.
                    </p>

                    <h4>How waves are declared: <code>EnemyStageData</code></h4>
                    <p>
                        Each entry in <code>StageData::enemies</code> is a <code>std::shared_ptr&lt;EnemyStageData&gt;</code> that
                        acts as an individual wave controller. It contains:
                    </p>
                    <ul>
                        <li><code>UID</code> — which template (EntityData) to spawn.</li>
                        <li><code>spawnStart</code>, <code>respawnTime</code>, <code>amount</code> — timing and count.</li>
                        <li><code>baseHealthThreshold</code> — conditional spawning based on base HP%.</li>
                        <li><code>magnification</code> — HP / attack scaling per wave.</li>
                        <li>flags like <code>isBoss</code> or <code>bypassEnemyLimit</code>.</li>
                    </ul>
                    <p>
                        During the <code>Stage::update()</code> loop the Stage iterates all <code>EnemyStageData</code> objects,
                        advances their internal timer, checks start / threshold / amount conditions, and calls
                        <code>spawn_enemy(...)</code> when appropriate. Because each wave keeps its own runtime fields
                        (<code>currentTimer</code>, <code>spawnedCount</code>, <code>hasStarted</code>), multiple waves can
                        run concurrently and express complex pacing patterns without additional code complexity.
                    </p>

                    <h4>Rewards: <code>RewardData</code></h4>
                    <p>
                        A <code>StageData</code> includes a list of <code>RewardData</code> describing what the player receives
                        when the stage is completed (e.g. "shells" currency, or unlocking a unit by <code>unitUID</code>).
                        The Stage hands these items to player data / progression systems when victory is detected.
                    </p>

                    <h4>Data-driven example (JSON snippet)</h4>
                    <p>Example of how a small part of a stage might be represented in JSON:</p>
                    <pre><code>{
  "uid": 12,
  "name": "Sandy Shoals",
  "enemiesLimit": 8,
  "length": 1200,
  "enemies": [
    {
      "uid": 101,
      "amount": 10,
      "spawnStart": 5.0,
      "respawnTime": 3.0,
      "magnification": [1.0, 1.0],
      "baseHealthThreshold": 100
    },
    {
      "uid": 201,
      "amount": -1,
      "spawnStart": 30.0,
      "respawnTime": 6.0,
      "isBoss": false,
      "bypassEnemyLimit": false
    }
  ],
  "rewards": [
    { "type": "shells", "amount": 200 },
    { "type": "unit", "unitUID": 12 }
  ]
}</code></pre>

                    <h4>Why this approach works</h4>
                    <p>
                        Putting waves and stage rules in data keeps level design outside the codebase: designers can tweak pacing,
                        toggle conditional spawns, or add boss beats by editing JSON rather than recompiling. The Stage itself
                        remains a deterministic runtime orchestrator: it evaluates data-driven conditions, updates per-wave timers,
                        and calls spawning APIs. This separation enables fast iteration and clear ownership between systems.
                    </p>

                    <h4>Integration with the rest of the system</h4>
                    <p>
                        The data flow at start-of-stage looks like:
                    </p>
                    <ol>
                        <li><code>DataLoader</code> reads <code>StageData</code> (and nested <code>EnemyStageData</code>) from JSON.</li>
                        <li><code>Stage::load()</code> initializes background, bases and populates the <code>m_enemyStageDatas</code> array.</li>
                        <li>
                            During gameplay, the Stage updates these <code>EnemyStageData</code> objects and spawns <code>BattleEnemy</code>
                            instances using the templates returned by the <code>DataLoader</code>.
                        </li>
                        <li>On stage completion the Stage grants <code>RewardData</code> items to the player progression system.</li>
                    </ol>

                    <h4>Practical benefits & tradeoffs</h4>
                    <p>
                        <strong>Benefits:</strong> fast level iteration, expressive control over timing and conditional spawns,
                        and ability to create overlapping / infinite waves. Because waves are self-contained, adding or removing
                        behaviour is low risk.
                    </p>
                    <p>
                        <strong>Tradeoffs / future iterations:</strong> the current approach embeds spawn logic as data, but for very complex
                        encounters a lightweight event script (or small DSL) could offer even more expressiveness. Also, adding schema
                        validation on load (JSON schema or hand-rolled checks) would improve resilience and surface designer errors early.
                    </p>

                    <h4>Suggestions for scale</h4>
                    <ul>
                        <li>Introduce an <code>EntityFactory</code> so all instantiation and dependency wiring is centralized.</li>
                        <li>Add JSON schema validation for <code>StageData</code> and <code>EnemyStageData</code> to catch misconfigured levels.</li>
                        <li>Consider a simple event system for waves (onStart, onSpawn, onFinish) to reduce special-case flags in data.</li>
                    </ul>

                </div>
            </details>

            <details class="technical-section">
                <summary>Game & Player Data</summary>
                <div class="technical-content">

                    <p>
                        The game relies a lot on external data files to define almost everything: units, enemies,
                        stages, chapters, and the player's progression. Instead of hardcoding these values,
                        I went for a data-driven approach using JSON files and a simple loader class called
                        <code>DataLoader</code>. This keeps the project flexible and avoids recompiling
                        every time I tweak balance values.
                    </p>

                    <h3>Why JSON?</h3>

                    <p>
                        JSON is readable, lightweight, and maps naturally to the kind of structures the game uses.
                        The <code>nlohmann::json</code> library also keeps parsing simple, so I didn't have
                        to write any custom parsing logic. It works especially well with nested structures such as
                        <code>EntityData</code> or <code>StageData</code>.
                    </p>

                    <h3>How the DataLoader works</h3>

                    <p>
                        All files are loaded at startup through one function: <code>DataLoader::load_all()</code>.
                        Each JSON file (units, enemies, stages, chapters, player data) is deserialized
                        into strongly-typed structures stored as <code>std::shared_ptr</code>. The loader is
                        intentionally simple: it only handles data, never gameplay logic.
                    </p>

                    <pre><code>
bool DataLoader::load_all()
{
    return load_units("game_data/units.json") &&
           load_enemies("game_data/enemies.json") &&
           load_stages("game_data/stages.json") &&
           load_chapters("game_data/chapters.json") &&
           load_player("game_data/player.json");
}
        </code></pre>

                    <h3>Units & Enemies Database</h3>

                    <p>
                        Units and enemies share the same C++ structure: <code>EntityData</code>.
                        All the gameplay parameters — stats, timings, textures, animations — come from their JSON files.
                        Player units can have multiple forms and upgrade levels. These variants are flattened into
                        a database using a composite key <code>(UID, form)</code>:
                    </p>

                    <pre><code>
m_unitsFormsDatabase[{UID, formID}] = data;
        </code></pre>

                    <p>
                        This makes lookups straightforward and avoids scattering form-selection logic across the codebase.
                    </p>

                    <h3>Stages, Waves, and Rewards</h3>

                    <p>
                        Stages are defined using <code>StageData</code>: enemy waves, spawn rates, backgrounds,
                        world length, limits, and completion rewards. Each wave corresponds to an
                        <code>EnemyStageData</code> entry that stores spawn timings, quantities, conditions
                        (like base-HP thresholds), and magnification values.
                    </p>

                    <p>
                        Rewards are stored as <code>RewardData</code>, allowing stages to give shells or unlock units
                        when completed.
                    </p>

                    <h3>Chapters & Player Progression</h3>

                    <p>
                        Chapters group stages together and give them map coordinates. Loading the chapter file is enough
                        for the world map UI to update automatically.
                    </p>

                    <p>
                        Player progression lives in <code>player.json</code>: owned units, forms, currency,
                        and completed stages. When the game closes, <code>DataLoader::terminate()</code> saves everything
                        back to disk using the same format.
                    </p>

                    <h3>Why this approach helps</h3>

                    <p>
                        Putting all static data in JSON keeps the project much easier to maintain.
                        Adding new content doesn't require touching C++ code, balancing becomes simpler,
                        and debugging is cleaner since every value has a single source of truth.
                        This also makes the project ready for future tools like an editor or basic modding.
                    </p>

                </div>
            </details>


            <details class="technical-section">
                <summary>UI System</summary>
                <div class="technical-content">
                    <p>
                        The UI system was designed to be lightweight, fully event-driven, and easy to extend.
                        Although the game has a simple presentation, the underlying UI architecture needed to be
                        flexible enough to support menus, gameplay HUD, animations, tooltips, and reactive buttons.
                    </p>

                    <h4>Core Principles</h4>
                    <p>
                        The system is built around three goals:
                    </p>
                    <p>
                        • A clean separation between UI logic and rendering<br>
                        • A lightweight hierarchy of UI widgets<br>
                        • A minimal event pipeline so every UI element reacts only to what matters to it
                    </p>

                    <h4>UI Hierarchy</h4>
                    <p>
                        Every screen is composed of <strong>widgets</strong>. A widget is a simple object with:
                    </p>
                    <p>
                        • A position and size<br>
                        • A visual renderer (texture, text, or colored quad)<br>
                        • Optional interactivity (clickable, hoverable)<br>
                        • Optional animation (fade, slide, pulse)
                    </p>
                    <p>
                        Widgets can contain child widgets. This avoids micromanaging positions everywhere and lets
                        entire UI panels move or fade with a single operation.
                    </p>

                    <h4>Rendering Pipeline</h4>
                    <p>
                        The UI renderer is intentionally minimal: it draws elements in a strict order based on their
                        depth. Each widget exposes a <code>Draw()</code> function, and the system simply walks the UI tree.
                    </p>
                    <p>
                        Because the game uses 2D sprites and bitmap fonts, keeping the draw order stable and predictable
                        was essential. No shader magic is involved — just clean batching and state-safe rendering.
                    </p>

                    <h4>Interaction Model</h4>
                    <p>
                        The UI system uses <strong>event filtering</strong>: instead of sending every click to
                        every widget, events propagate through the UI tree until something claims them.
                    </p>
                    <p>
                        This avoids spaghetti logic and keeps input code small. For example:
                    </p>
                    <p>
                        • Buttons only care about mouse hover and mouse press<br>
                        • Tooltips are notified when an element gains focus<br>
                        • Tabs listen for click events but ignore anything else<br>
                    </p>

                    <h4>Animations</h4>
                    <p>
                        Instead of relying on a heavy animation library, each widget can attach a small
                        <strong>UIAnimation</strong> object that updates its alpha, position, or size over time.
                    </p>
                    <p>
                        These animations are extremely cheap computationally and easy to chain. For example, buttons
                        use a short scale-pulse on hover, making the UI feel alive without overcomplicating the codebase.
                    </p>

                    <h4>HUD Integration</h4>
                    <p>
                        The gameplay HUD (base health, shells, unit buttons, cooldowns) sits on top of the same widget system.
                        This means HUD elements benefit from the same interactions and animations as any menu component.
                    </p>
                    <p>
                        Because of this unification, features like scaling effects, flashing warnings, and dynamic updates
                        took only a few lines of code.
                    </p>

                    <h4>Why This Matters</h4>
                    <p>
                        The UI system ended up being both simple and surprisingly powerful. Building it from scratch
                        forced me to think about:
                    </p>
                    <p>
                        • Responsiveness and input filtering<br>
                        • Scene layering and draw order<br>
                        • Reusable components instead of bespoke menus<br>
                        • The trade-off between power and complexity in UI frameworks
                    </p>
                    <p>
                        It's a compact system, but it taught me the fundamentals of designing reactive views without
                        relying on game engines or prefab UI tools.
                    </p>
                </div>
            </details>


            <details class="technical-section">
                <summary>Debug Tools</summary>
                <div class="technical-content">
                    <p>
                        ImGui allows inspecting entity properties, adjusting stats, spawning enemies and visualizing
                        hitboxes while the game is running.
                    </p>
                </div>
            </details>

            <details class="technical-section">
                <summary>What I Learned</summary>
                <div class="technical-content">
                    <p>
                        This project has been a major step in learning how to structure real-world systems instead of
                        writing ad-hoc gameplay code.
                    </p>
                </div>
            </details>

        </section>

    </main>

    <footer>
        © Najim Bakkali 2025
    </footer>

</body>
</html>
