<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fish Fighters | Najim Bakkali</title>
    <link rel="stylesheet" href="../css/style.css">
</head>

<body class="project-page">

    <nav>
        <a href="../index.html">Home</a>
        <a href="../projects.html">Projects</a>
        <a href="../contact.html">Contact</a>
    </nav>

    <main>

        <!-- ========================= -->
        <!--        HEADER SECTION     -->
        <!-- ========================= -->
        <section class="project-header">

            <h1 class="project-title">Fish Fighters</h1>
            <p class="project-subtitle">A personal C++ tower defense project built with SFML.</p>

            <!-- IMAGE CAROUSEL -->
            <div class="carousel-container">

                <!-- Radio buttons -->
                <input type="radio" name="slides" id="slide1" checked>
                <input type="radio" name="slides" id="slide2">
                <input type="radio" name="slides" id="slide3">

                <!-- Slides -->
                <div class="carousel-slides">

                    <div class="carousel-slide">
                        <img src="../img/hacknescape_1.png" alt="Fish Fighters Screenshot">
                    </div>

                    <div class="carousel-slide">
                        <img src="../img/hacknescape_2.png" alt="Fish Fighters Screenshot">
                    </div>

                    <div class="carousel-slide">
                        <img src="../img/hacknescape_3.png" alt="Fish Fighters Screenshot">
                    </div>

                </div>

                <!-- Arrows for slide 1 -->
                <label for="slide3" class="carousel-arrow left-arrow left1">&#10094;</label>
                <label for="slide2" class="carousel-arrow right-arrow right1">&#10095;</label>

                <!-- Arrows for slide 2 -->
                <label for="slide1" class="carousel-arrow left-arrow left2">&#10094;</label>
                <label for="slide3" class="carousel-arrow right-arrow right2">&#10095;</label>

                <!-- Arrows for slide 3 -->
                <label for="slide2" class="carousel-arrow left-arrow left3">&#10094;</label>
                <label for="slide1" class="carousel-arrow right-arrow right3">&#10095;</label>

            </div>


            <div class="project-info-layout">

                <!-- SIDEBAR TECH INFO -->
                <aside class="project-sidebar">

                    <h3>Platform:</h3>
                    <p>Windows PC</p>

                    <h3>Engine:</h3>
                    <p>Custom C++ Engine (SFML)</p>

                    <h3>Language:</h3>
                    <p>C++20</p>

                    <h3>Tools Used:</h3>
                    <p>Visual Studio 2022, SFML 3.0, ImGui, CMake</p>

                    <h3>Duration:</h3>
                    <p>3 months</p>

                    <h3>Team Size:</h3>
                    <p>1</p>

                    <h3>Role:</h3>
                    <p>Gameplay Programmer, Tools Programmer, Technical Designer</p>

                </aside>

                <!-- OVERVIEW -->
                <section class="project-overview">

                    <h2>Overview</h2>

                    <p>
                        Fish Fighters started as a personal challenge to push myself beyond the short, contained projects
                        I had done before. I wanted to understand what it really takes to structure a larger game, the kind
                        that forces you to think ahead instead of just writing code until it works.
                    </p>

                    <p>
                        A tower-defense game inspired by <em>The Battle Cats</em> felt like the perfect project.
                        It’s simple enough to build alone, but it hides just enough complexity to make you think carefully
                        about architecture, game flow, and data organization.
                    </p>

                    <p>
                        This project wasn’t about making the flashiest game possible. It was about learning how to build
                        something clean and modular, something that could grow without collapsing under its own weight.
                    </p>

                    <h2>Project Goals</h2>

                    <ul>
                        <li>Build a complete small game entirely in modern C++.</li>
                        <li>Design clean, modular systems (state machines, data-driven units, etc.).</li>
                        <li>Experiment with JSON-driven gameplay data.</li>
                        <li>Practice maintainable architecture over rapid prototyping.</li>
                        <li>Develop tools to iterate on gameplay without recompilation.</li>
                    </ul>

                    <h2>Links</h2>

                    <a href="https://github.com/Najimandroid/Fish_Fighters"
                       class="btn" target="_blank">
                        View Source Code on GitHub
                    </a>

                </section>

            </div>

        </section>

        <hr class="section-divider">


        <!-- ========================= -->
        <!--       VIDEO SECTION       -->
        <!-- ========================= -->
        <section class="project-video">

            <h2>Demo Reel</h2>

            <div class="video-wrapper">
                <iframe width="100%" height="500"
                        src="https://www.youtube.com/embed/OKkgqlkqQys"
                        title="Fish Fighters Gameplay Video"
                        frameborder="0"
                        allowfullscreen>
                </iframe>
            </div>

        </section>

        <hr class="section-divider">


        <!-- ========================= -->
        <!--      TECHNICAL SECTION    -->
        <!-- ========================= -->
        <section>

            <h2>Technical Breakdown</h2>

            <details class="technical-section">
                <summary>Project Architecture</summary>
                <div class="technical-content">
                    <p>
                        When I started Fish Fighters, my goal wasn’t simply to make a game — it was to
                        build a maintainable codebase with clear ownership, modular systems, and predictable behavior.
                    </p>
                </div>
            </details>

            <details class="technical-section">
                <summary>Game Entities</summary>
                <div class="technical-content">

                    <h4>Concept: Templates vs. Runtime Instances</h4>
                    <p>
                        In Fish Fighters each unit exists in two distinct forms:
                        a <strong>data template</strong> and a <strong>runtime instance</strong>.
                        The template is represented by the <code>EntityData</code> struct (serializable to JSON)
                        and contains only raw values (cost, health, attackPower, texture path, etc.).
                        The runtime actor is a <code>BattleEntity</code> (concrete types: <code>BattleUnit</code>, <code>BattleEnemy</code>)
                        which owns state, animations, hitboxes and a <code>StateMachine</code>.
                    </p>

                    <h4>Why this separation?</h4>
                    <p>
                        Separating data from behavior gives several practical benefits:
                        it makes the game <em>data-driven</em> (UI and tools can read templates directly),
                        prevents accidental mutation of template values during gameplay,
                        and keeps the runtime objects focused on behaviour, not storage.
                        This approach mirrors patterns used in production engines (ScriptableObjects / data assets).
                    </p>

                    <h4>Instantiation (how entities are spawned)</h4>
                    <p>
                        Entities are created by the <code>Stage</code> using an <code>EntityData</code> pointer returned by the <code>DataLoader</code>.
                        The runtime instance holds a shared pointer to its template:
                        <code>std::shared_ptr<EntityData> data</code>, and copies/derives runtime fields (currentHealth, cooldown, etc.)
                        from that template upon construction.
                    </p>

                    <p><strong>Example (simplified):</strong></p>
                    <pre><code>// create a BattleEnemy from template data
auto data = m_dataLoader->get_enemy_data(uid);
auto enemy = std::make_shared<BattleEnemy>(data, magnification);
enemy->set_current_stage(shared_from_this());
enemy->init_state_machine();
enemy->stateMachine->change_state(std::make_unique<IdleState>(enemy->stateMachine));
m_enemies[enemy->currentLayer].push_back(enemy);
</code></pre>

                    <h4>Runtime modifiers and magnification</h4>
                    <p>
                        Templates stay immutable while a <code>BattleEntity</code> computes its runtime stats at spawn.
                        For example, player progression or level multipliers are applied through a <code>magnification</code> vector:
                        <code>sf::Vector2f magnification</code> where <code>.x</code> affects HP and <code>.y</code> affects attack.
                        This makes it trivial to support buffs, upgrades or difficulty scaling without altering templates.
                    </p>

                    <h4>Hitboxes, visuals and derived values</h4>
                    <p>
                        Several runtime values are derived from template fields: hitbox size is calculated from the entity texture
                        (larger textures → larger hitboxes), attack & damage zones are computed from <code>damageZone</code> offsets,
                        and animation frame timing is driven by template frame counts + a per-instance timer.
                        Keeping these derived calculations in the instance keeps the template clean and the logic explicit.
                    </p>

                    <h4>Entities and the rest of the system</h4>
                    <p>
                        Because the template is accessible project-wide, UI screens (shop, unit info) read <code>EntityData</code>
                        directly to show cost, description and iconography. Meanwhile the gameplay loop working in <code>Stage::update()</code>
                        operates on collections of <code>BattleEntity</code> instances for targeting, collision and wave flow.
                    </p>

                    <h4>Benefits observed</h4>
                    <ul>
                        <li>Easy tuning: add or tweak units by editing JSON — no recompilation required.</li>
                        <li>Cleaner code: runtime state and data are not mixed, which reduced bugs during refactors.</li>
                        <li>Reusability: same template used by UI, spawn logic and analytics tools.</li>
                    </ul>

                </div>
            </details>


            <section class="technical-section">
                <details>
                    <summary>Entities’ State Machine</summary>
                    <div>
                        <p>
                            Each <code>BattleEntity</code> in the game is driven by a dedicated
                            <code>StateMachine</code> responsible for handling behaviour such as idling,
                            walking, attacking, or being knocked back. Instead of relying on a large
                            <code>switch</code> statement or a shared enum, each behaviour is encapsulated
                            inside its own class derived from <code>BaseState</code>. This keeps logic
                            isolated and makes transitions explicit and maintainable.
                        </p>

                        <h4>Architecture</h4>
                        <p>
                            The <code>StateMachine</code> owns a single active state through a
                            <code>std::unique_ptr&lt;BaseState&gt;</code>. States are lightweight objects
                            that hold a reference back to the machine, allowing them to request transitions
                            when needed. A state follows a clear lifecycle:
                        </p>

                        <p>
                            • <code>enter()</code> is called exactly once when the state becomes active.
                            • <code>perform()</code> runs every frame and contains the state’s logic.
                            • <code>exit()</code> is called exactly once before the state is replaced.
                        </p>

                        <p>
                            Transitioning from one state to another happens through
                            <code>change_state()</code>, which automatically calls <code>exit()</code> on
                            the old state and <code>enter()</code> on the new one. Because the machine holds
                            the state via <code>unique_ptr</code>, ownership and lifetime are always clear.
                        </p>

                        <h4>Example: AttackState</h4>
                        <p>
                            The <code>AttackState</code> handles everything related to an attack cycle. It
                            manages foreswing timing, applies damage at the right moment, checks for valid
                            targets, and determines the next state once the attack is finished. It can
                            transition to different states depending on the context:
                        </p>

                        <p>
                            • No target in range → switch to <code>WalkState</code>
                            • Attack executed → return to <code>IdleState</code>
                            • Entity is knocked back → switch to <code>KnockbackState</code>
                        </p>

                        <p>
                            Because the attack behaviour is isolated inside its own class, the entity’s
                            main update function stays clean. The <code>BattleEntity</code> simply calls
                            <code>stateMachine->update_state(deltaTime)</code> each frame.
                        </p>

                        <h4>Why this design works</h4>
                        <p>
                            Before this system, entity behaviour was handled through a large
                            <code>switch</code> statement inside <code>BattleEntity</code>. As more
                            behaviours were added, the code became hard to read, harder to extend, and easy
                            to break. By moving each behaviour into its own class, the logic became modular
                            and easier to reason about. States can now evolve independently without creating
                            chain reactions of side effects.
                        </p>

                        <p>
                            This design also makes debugging significantly simpler: the active state is
                            always known, transitions are explicit, and each behaviour is contained in a
                            well-defined place in the codebase. Adding new behaviour, like a stun state or a
                            charge attack, only requires adding a new class and defining its transitions.
                        </p>
                    </div>
                </details>
            </section>


            <details class="technical-section">
                <summary>Stages, Waves & Rewards</summary>
                <div class="technical-content">

                    <h4>Role of <code>StageData</code></h4>
                    <p>
                        <code>StageData</code> is the level blueprint: it describes a stage’s rules (limits, base health, length),
                        visuals (backgrounds, base textures), which enemy waves will appear, and what rewards the player receives
                        on completion. At runtime the <code>Stage</code> is initialized from a <code>StageData</code> instance so
                        the gameplay code can remain generic and driven by data only.
                    </p>

                    <h4>How waves are declared: <code>EnemyStageData</code></h4>
                    <p>
                        Each entry in <code>StageData::enemies</code> is a <code>std::shared_ptr&lt;EnemyStageData&gt;</code> that
                        acts as an individual wave controller. It contains:
                    </p>
                    <ul>
                        <li><code>UID</code> — which template (EntityData) to spawn.</li>
                        <li><code>spawnStart</code>, <code>respawnTime</code>, <code>amount</code> — timing and count.</li>
                        <li><code>baseHealthThreshold</code> — conditional spawning based on base HP%.</li>
                        <li><code>magnification</code> — HP / attack scaling per wave.</li>
                        <li>flags like <code>isBoss</code> or <code>bypassEnemyLimit</code>.</li>
                    </ul>
                    <p>
                        During the <code>Stage::update()</code> loop the Stage iterates all <code>EnemyStageData</code> objects,
                        advances their internal timer, checks start / threshold / amount conditions, and calls
                        <code>spawn_enemy(...)</code> when appropriate. Because each wave keeps its own runtime fields
                        (<code>currentTimer</code>, <code>spawnedCount</code>, <code>hasStarted</code>), multiple waves can
                        run concurrently and express complex pacing patterns without additional code complexity.
                    </p>

                    <h4>Rewards: <code>RewardData</code></h4>
                    <p>
                        A <code>StageData</code> includes a list of <code>RewardData</code> describing what the player receives
                        when the stage is completed (e.g. "shells" currency, or unlocking a unit by <code>unitUID</code>).
                        The Stage hands these items to player data / progression systems when victory is detected.
                    </p>

                    <h4>Data-driven example (JSON snippet)</h4>
                    <p>Example of how a small part of a stage might be represented in JSON:</p>
                    <pre><code>{
  "uid": 12,
  "name": "Sandy Shoals",
  "enemiesLimit": 8,
  "length": 1200,
  "enemies": [
    {
      "uid": 101,
      "amount": 10,
      "spawnStart": 5.0,
      "respawnTime": 3.0,
      "magnification": [1.0, 1.0],
      "baseHealthThreshold": 100
    },
    {
      "uid": 201,
      "amount": -1,
      "spawnStart": 30.0,
      "respawnTime": 6.0,
      "isBoss": false,
      "bypassEnemyLimit": false
    }
  ],
  "rewards": [
    { "type": "shells", "amount": 200 },
    { "type": "unit", "unitUID": 12 }
  ]
}</code></pre>

                    <h4>Why this approach works</h4>
                    <p>
                        Putting waves and stage rules in data keeps level design outside the codebase: designers can tweak pacing,
                        toggle conditional spawns, or add boss beats by editing JSON rather than recompiling. The Stage itself
                        remains a deterministic runtime orchestrator: it evaluates data-driven conditions, updates per-wave timers,
                        and calls spawning APIs. This separation enables fast iteration and clear ownership between systems.
                    </p>

                    <h4>Integration with the rest of the system</h4>
                    <p>
                        The data flow at start-of-stage looks like:
                    </p>
                    <ol>
                        <li><code>DataLoader</code> reads <code>StageData</code> (and nested <code>EnemyStageData</code>) from JSON.</li>
                        <li><code>Stage::load()</code> initializes background, bases and populates the <code>m_enemyStageDatas</code> array.</li>
                        <li>
                            During gameplay, the Stage updates these <code>EnemyStageData</code> objects and spawns <code>BattleEnemy</code>
                            instances using the templates returned by the <code>DataLoader</code>.
                        </li>
                        <li>On stage completion the Stage grants <code>RewardData</code> items to the player progression system.</li>
                    </ol>

                    <h4>Practical benefits & tradeoffs</h4>
                    <p>
                        <strong>Benefits:</strong> fast level iteration, expressive control over timing and conditional spawns,
                        and ability to create overlapping / infinite waves. Because waves are self-contained, adding or removing
                        behaviour is low risk.
                    </p>
                    <p>
                        <strong>Tradeoffs / future iterations:</strong> the current approach embeds spawn logic as data, but for very complex
                        encounters a lightweight event script (or small DSL) could offer even more expressiveness. Also, adding schema
                        validation on load (JSON schema or hand-rolled checks) would improve resilience and surface designer errors early.
                    </p>

                    <h4>Suggestions for scale</h4>
                    <ul>
                        <li>Introduce an <code>EntityFactory</code> so all instantiation and dependency wiring is centralized.</li>
                        <li>Add JSON schema validation for <code>StageData</code> and <code>EnemyStageData</code> to catch misconfigured levels.</li>
                        <li>Consider a simple event system for waves (onStart, onSpawn, onFinish) to reduce special-case flags in data.</li>
                    </ul>

                </div>
            </details>


            <details class="technical-section">
                <summary>Game & Player Data</summary>
                <div class="technical-content">

                    <p>
                        The game relies heavily on external data files to describe nearly all its static and persistent content:
                        units, enemies, stages, chapters, and the player's progression. Instead of hardcoding these values inside
                        the engine, a fully data-driven system built around JSON files and a dedicated <code>DataLoader</code>
                        handles everything dynamically. This makes content tuning faster, safer, and more scalable.
                    </p>

                    <h3>Why JSON?</h3>

                    <p>
                        JSON was selected because it is easy to read, supports nested structures, and integrates naturally with
                        the <code>nlohmann::json</code> library. Entities, stages, rewards, and chapters all map cleanly to JSON
                        objects without requiring any custom parsing logic.
                    </p>

                    <p>
                        Choosing JSON over a proprietary format reduces maintenance cost and complexity. It prevents parser bugs,
                        simplifies debugging, and lets the focus remain on gameplay instead of tooling.
                    </p>

                    <h3>DataLoader: A Centralized Loading System</h3>

                    <p>
                        All game data is loaded at startup through a single entry point: <code>DataLoader::load_all()</code>.
                        This function reads JSON files, converts parsed objects into strongly typed C++ structures,
                        and stores them into internal databases.
                    </p>

                    <pre><code>
bool DataLoader::load_all()
{
    return load_units("game_data/units.json") &&
           load_enemies("game_data/enemies.json") &&
           load_stages("game_data/stages.json") &&
           load_chapters("game_data/chapters.json") &&
           load_player("game_data/player.json");
}
        </code></pre>

                    <p>
                        Each loading function maps one JSON file to a local database stored using <code>std::shared_ptr</code>.
                        The loader performs no gameplay logic: it only deserializes data and guarantees correctness.
                    </p>

                    <h3>Units & Enemies Database</h3>

                    <p>
                        Both units and enemies are described using <code>EntityData</code>. The JSON format defines stats, attack
                        timings, textures, animations, and movement values. For player units, multiple forms and levels can be
                        defined inside the same JSON entry.
                    </p>

                    <p>
                        These forms are flattened into the <code>m_unitsFormsDatabase</code> using a composite key
                        <code>(UID, form)</code>, making retrieval deterministic while keeping loading logic contained in one place.
                    </p>

                    <pre><code>
m_unitsFormsDatabase[{UID, formID}] = data;
        </code></pre>

                    <h3>Stages, Waves, and Rewards</h3>

                    <p>
                        The game's levels are fully defined through <code>StageData</code>: enemy limits, base health,
                        battlefield length, backgrounds, and wave sequencing. Each wave is represented by an
                        <code>EnemyStageData</code> structure describing spawn delays, timers, quantities, and conditional
                        triggers such as base-health thresholds.
                    </p>

                    <p>
                        Completion rewards are stored as <code>RewardData</code> and can grant currency or unlock new units.
                        This makes stage progression tunable directly through data files.
                    </p>

                    <h3>Chapters: World Structure</h3>

                    <p>
                        Chapters group stages together and define their position on the world map. The JSON file contains
                        a list of stage IDs with coordinates. Once loaded, the UI simply reads this data to build the overworld
                        dynamically.
                    </p>

                    <h3>PlayerData: Persistent Progression</h3>

                    <p>
                        The player's progression lives in <code>player.json</code>. It stores currency, owned units, equipped
                        units, and completed levels. The DataLoader converts this into a <code>PlayerData</code> structure shared
                        across the entire game through <code>std::shared_ptr</code>.
                    </p>

                    <pre><code>
m_playerData->shells = j["money"]["shells"];
m_playerData->ownedUnits[uid] = { level, form };
m_playerData->completedStages.insert(stageUid);
        </code></pre>

                    <p>
                        When the game closes, <code>DataLoader::terminate()</code> serializes the updated progression back into
                        JSON. Loading and saving rely on the same structure, which ensures stability and long-term consistency.
                    </p>

                    <h3>Architectural Benefits</h3>

                    <p>
                        This fully data-driven design provides several major long-term advantages:
                    </p>

                    <ul>
                        <li>No C++ changes are required to add new content.</li>
                        <li>Balancing becomes safe and immediate.</li>
                        <li>JSON files document the entire game structure.</li>
                        <li>Logic remains isolated from data.</li>
                        <li>Debugging is simpler because all values have a single authoritative source.</li>
                    </ul>

                    <p>
                        This architecture keeps the engine clean and makes the project scalable. It even opens the door to
                        future features such as an in-game editor or modding support.
                    </p>

                </div>
            </details>



            <details class="technical-section">
                <summary>UI System</summary>
                <div class="technical-content">
                    <p>
                        The UI system was designed to be lightweight, fully event-driven, and easy to extend.
                        Although the game has a simple presentation, the underlying UI architecture needed to be
                        flexible enough to support menus, gameplay HUD, animations, tooltips, and reactive buttons.
                    </p>

                    <h4>Core Principles</h4>
                    <p>
                        The system is built around three goals:
                    </p>
                    <p>
                        • A clean separation between UI logic and rendering<br>
                        • A lightweight hierarchy of UI widgets<br>
                        • A minimal event pipeline so every UI element reacts only to what matters to it
                    </p>

                    <h4>UI Hierarchy</h4>
                    <p>
                        Every screen is composed of <strong>widgets</strong>. A widget is a simple object with:
                    </p>
                    <p>
                        • A position and size<br>
                        • A visual renderer (texture, text, or colored quad)<br>
                        • Optional interactivity (clickable, hoverable)<br>
                        • Optional animation (fade, slide, pulse)
                    </p>
                    <p>
                        Widgets can contain child widgets. This avoids micromanaging positions everywhere and lets
                        entire UI panels move or fade with a single operation.
                    </p>

                    <h4>Rendering Pipeline</h4>
                    <p>
                        The UI renderer is intentionally minimal: it draws elements in a strict order based on their
                        depth. Each widget exposes a <code>Draw()</code> function, and the system simply walks the UI tree.
                    </p>
                    <p>
                        Because the game uses 2D sprites and bitmap fonts, keeping the draw order stable and predictable
                        was essential. No shader magic is involved — just clean batching and state-safe rendering.
                    </p>

                    <h4>Interaction Model</h4>
                    <p>
                        The UI system uses <strong>event filtering</strong>: instead of sending every click to
                        every widget, events propagate through the UI tree until something claims them.
                    </p>
                    <p>
                        This avoids spaghetti logic and keeps input code small. For example:
                    </p>
                    <p>
                        • Buttons only care about mouse hover and mouse press<br>
                        • Tooltips are notified when an element gains focus<br>
                        • Tabs listen for click events but ignore anything else<br>
                    </p>

                    <h4>Animations</h4>
                    <p>
                        Instead of relying on a heavy animation library, each widget can attach a small
                        <strong>UIAnimation</strong> object that updates its alpha, position, or size over time.
                    </p>
                    <p>
                        These animations are extremely cheap computationally and easy to chain. For example, buttons
                        use a short scale-pulse on hover, making the UI feel alive without overcomplicating the codebase.
                    </p>

                    <h4>HUD Integration</h4>
                    <p>
                        The gameplay HUD (base health, shells, unit buttons, cooldowns) sits on top of the same widget system.
                        This means HUD elements benefit from the same interactions and animations as any menu component.
                    </p>
                    <p>
                        Because of this unification, features like scaling effects, flashing warnings, and dynamic updates
                        took only a few lines of code.
                    </p>

                    <h4>Why This Matters</h4>
                    <p>
                        The UI system ended up being both simple and surprisingly powerful. Building it from scratch
                        forced me to think about:
                    </p>
                    <p>
                        • Responsiveness and input filtering<br>
                        • Scene layering and draw order<br>
                        • Reusable components instead of bespoke menus<br>
                        • The trade-off between power and complexity in UI frameworks
                    </p>
                    <p>
                        It's a compact system, but it taught me the fundamentals of designing reactive views without
                        relying on game engines or prefab UI tools.
                    </p>
                </div>
            </details>


            <details class="technical-section">
                <summary>Debug Tools</summary>
                <div class="technical-content">
                    <p>
                        ImGui allows inspecting entity properties, adjusting stats, spawning enemies and visualizing
                        hitboxes while the game is running.
                    </p>
                </div>
            </details>

            <details class="technical-section">
                <summary>What I Learned</summary>
                <div class="technical-content">
                    <p>
                        This project has been a major step in learning how to structure real-world systems instead of
                        writing ad-hoc gameplay code.
                    </p>
                </div>
            </details>

        </section>

    </main>

    <footer>
        © Najim Bakkali 2025
    </footer>

</body>
</html>
